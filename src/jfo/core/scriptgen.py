from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timezone
from pathlib import PurePosixPath
from typing import List

from .operations import OperationKind
from .plan import Plan
from .quoting import bash_array_literal, bash_quote


@dataclass(frozen=True)
class ScriptOptions:
    allowed_roots: List[str]
    dry_run: bool = True
    no_overwrite: bool = True
    show_linkcount: bool = True
    on_exists: str = "error"  # 'error' or 'skip'


def _normalize_root(root: str) -> str:
    r = str(PurePosixPath(root))
    if not r.endswith("/"):
        r += "/"
    return r


_HELPERS = r'''
log() {
  # ISO 8601 timestamp
  local ts; ts=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
  echo "[$ts]" "$@"
}

die() { log "ERROR:" "$@"; exit 1; }

have() { command -v "$1" >/dev/null 2>&1; }

resolve_path() {
  local p="$1"
  if have realpath; then
    realpath -m -- "$p"
  elif have readlink; then
    # -m is not everywhere; fallback
    readlink -m -- "$p" 2>/dev/null || readlink -f -- "$p" 2>/dev/null || echo "$p"
  else
    echo "$p"
  fi
}

assert_in_roots() {
  local p="$1"
  local rp; rp=$(resolve_path "$p")
  local root
  for root in "${ROOTS[@]}"; do
    case "$rp" in
      "$root"*) return 0 ;;
    esac
  done
  die "Path outside allowed roots:" "$rp"
}

run() {
  if [[ "$DRY_RUN" == "1" ]]; then
    log "DRY:" "$@"
  else
    log "RUN:" "$@"
    "$@"
  fi
}

ensure_parent() {
  local p="$1"
  local d; d=$(dirname -- "$p")
  assert_in_roots "$d"
  run mkdir -p -- "$d"
}

safe_mkdir() {
  local d="$1"
  assert_in_roots "$d"
  run mkdir -p -- "$d"
}

safe_mv() {
  local src="$1" dst="$2"
  assert_in_roots "$src"
  assert_in_roots "$dst"
  if [[ ! -e "$src" ]]; then die "Source missing:" "$src"; fi
  if [[ -e "$dst" && "$NO_OVERWRITE" == "1" ]]; then
    if [[ "$ON_EXISTS" == "skip" ]]; then
      log "SKIP exists:" "$dst"
      return 0
    fi
    die "Destination exists:" "$dst"
  fi
  ensure_parent "$dst"
  run mv -- "$src" "$dst"
}

safe_cp() {
  local src="$1" dst="$2"
  assert_in_roots "$src"
  assert_in_roots "$dst"
  if [[ ! -e "$src" ]]; then die "Source missing:" "$src"; fi
  if [[ -e "$dst" && "$NO_OVERWRITE" == "1" ]]; then
    if [[ "$ON_EXISTS" == "skip" ]]; then
      log "SKIP exists:" "$dst"
      return 0
    fi
    die "Destination exists:" "$dst"
  fi
  ensure_parent "$dst"
  run cp -a -- "$src" "$dst"
}

dev_id() {
  # device id of file or directory
  local p="$1"
  if have stat; then
    stat -c '%d' -- "$p"
  else
    echo ""
  fi
}

assert_same_fs() {
  local src="$1" dst_dir="$2"
  if ! have stat; then return 0; fi
  local a b
  a=$(dev_id "$src")
  b=$(dev_id "$dst_dir")
  if [[ -n "$a" && -n "$b" && "$a" != "$b" ]]; then
    die "Hardlink requires same filesystem:" "$src" "->" "$dst_dir"
  fi
}

safe_ln() {
  local src="$1" dst="$2"
  assert_in_roots "$src"
  assert_in_roots "$dst"
  if [[ ! -e "$src" ]]; then die "Source missing:" "$src"; fi
  if [[ -e "$dst" && "$NO_OVERWRITE" == "1" ]]; then
    if [[ "$ON_EXISTS" == "skip" ]]; then
      log "SKIP exists:" "$dst"
      return 0
    fi
    die "Destination exists:" "$dst"
  fi
  ensure_parent "$dst"
  local dst_dir; dst_dir=$(dirname -- "$dst")
  assert_same_fs "$src" "$dst_dir"
  run ln -- "$src" "$dst"
  if [[ "$SHOW_LINKCOUNT" == "1" && "$DRY_RUN" != "1" && -e "$dst" ]] && have stat; then
    local lc; lc=$(stat -c '%h' -- "$dst" 2>/dev/null || true)
    log "LINKCOUNT:" "$dst" "$lc"
  fi
}
'''


def generate_bash_script(plan: Plan, *, options: ScriptOptions) -> str:
    """Generate a self-contained Bash script that executes the selected operations."""

    created = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    roots = [_normalize_root(r) for r in options.allowed_roots if r.strip()]
    if not roots:
        # Force the runtime sandbox to fail loudly.
        roots = ["/__NO_ALLOWED_ROOTS_CONFIGURED__/"]

    lines: List[str] = []
    lines.append("#!/usr/bin/env bash")
    lines.append("set -euo pipefail")
    lines.append("IFS=$'\\n\\t'")
    # Avoid glob expansion (folder names include '*')
    lines.append("set -f")
    lines.append("")

    lines.append("# Generated by Jellyfin Organizer (JFO)")
    lines.append(f"# Plan: {plan.title}")
    lines.append(f"# Created (UTC): {created}")
    if plan.warnings:
        lines.append("# Plan warnings:")
        for w in plan.warnings:
            lines.append(f"#   - {w}")
    lines.append("")

    lines.append(f"DRY_RUN={'1' if options.dry_run else '0'}")
    lines.append(f"NO_OVERWRITE={'1' if options.no_overwrite else '0'}")
    lines.append(f"ON_EXISTS={bash_quote(options.on_exists)}")
    lines.append(f"SHOW_LINKCOUNT={'1' if options.show_linkcount else '0'}")
    lines.append(f"ROOTS={bash_array_literal(roots)}")
    lines.append("")

    lines.append(_HELPERS.strip("\n"))
    lines.append("")
    lines.append("# ---- Operations ----")
    # Make Dry-Run unmistakable in logs. Users often expect that clicking "AusfÃ¼hren"
    # actually changes files; with Dry-Run enabled we only print what would happen.
    lines.append('if [[ "$DRY_RUN" == "1" ]]; then log "INFO: DRY-RUN enabled - no changes will be made."; fi')

    selected_ops = [op for op in plan.operations if op.selected]
    if not selected_ops:
        lines.append("log 'No selected operations. Nothing to do.'")
        return "\n".join(lines) + "\n"

    for idx, op in enumerate(selected_ops, start=1):
        if op.kind == OperationKind.MKDIR:
            d = op.dst or op.src
            if not d:
                continue
            lines.append(f"# {idx}. mkdir {d}")
            lines.append(f"safe_mkdir {bash_quote(d)}")
        elif op.kind in (OperationKind.MOVE, OperationKind.RENAME):
            if not op.src or not op.dst:
                continue
            lines.append(f"# {idx}. mv {op.src} -> {op.dst}")
            lines.append(f"safe_mv {bash_quote(op.src)} {bash_quote(op.dst)}")
        elif op.kind == OperationKind.COPY:
            if not op.src or not op.dst:
                continue
            lines.append(f"# {idx}. cp {op.src} -> {op.dst}")
            lines.append(f"safe_cp {bash_quote(op.src)} {bash_quote(op.dst)}")
        elif op.kind == OperationKind.LINK:
            if not op.src or not op.dst:
                continue
            lines.append(f"# {idx}. ln {op.src} -> {op.dst}")
            lines.append(f"safe_ln {bash_quote(op.src)} {bash_quote(op.dst)}")
        else:
            lines.append(f"# {idx}. (unsupported op) {op.kind}")

        if op.warning:
            lines.append(f"#   WARNING: {op.warning}")

    lines.append("# ---- Done ----")
    lines.append("log 'Done.'")

    return "\n".join(lines) + "\n"
